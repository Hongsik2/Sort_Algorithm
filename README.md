# 정렬 알고리즘

- 버블 정렬, 삽입 정렬, 선택 정렬, 쉘 정렬을 구현하고, 성능을 평가함.

## 알고리즘의 개념과 장단점

### 버블 정렬

```java
static class BubbleSort implements Sorting {        	//버블 정렬
        public void sort(int[] a, int num) {			//배열 a와 배열의 길이를 입력받음
            for (int i = 0; i < num - 1; i++) {			
                for (int j = 0; j < num - i - 1; j++) {
                    if (a[j] > a[j + 1]) {				//처음 수가 나중에 있는 수보다 크면
                        int temp = a[j + 1];			//서로 자리를 바꾼다
                        a[j + 1] = a[j];
                        a[j] = temp;
                    }
                }
            }
        }
    }
```

#### 개념

- 서로 인접한 두 원소를 비교하여 순서대로 되어있지 않으면 순서를 교환하는 알고리즘
- 1회차 교환이 끝나면 가장 큰 원소가 맨 뒤로 이동하기 때문에 그 다음 교환은 마지막 원소를 제외하고 함.

#### 장점

1. 구현하기가 쉽다

#### 단점

1. 가장 큰 수가 가장 처음에 나온다면 그 수는 맨 끝으로 가기 위해 많은 횟수의 교환을 해야된다.
2. 자료의 이동보다 복잡한 자료의 위치 교환을 사용한다.



### 선택 정렬

```java
static class SelectionSort implements Sorting {     	//선택 정렬
        public void sort(int[] a, int num) {			//배열 a와 배열의 길이를 입력받음
            for (int i = 0; i < num - 1; i++) {
                int min = i;							
                for (int j = i + 1; j < num; j++) {		//a[i]~a[n-1]에서 최솟값을 찾는다.
                    if (a[j] < a[min]) min = j;
                }
                int temp = a[i];			//a[i]~a[n-1]에서의 최솟값과 a[i]와 위치를 바꾼다	
                a[i] = a[min];
                a[min] = temp;
            }
        }
    }
```

#### 개념

- 배열에서 최솟값을 찾은 후 그 값을 가장 앞의 값과 교환한다.
- 1회차 교환이 끝나면 맨 앞의 수는 최솟값이기 때문에 그 다음 수 부터 가장 작은 값을 찾아 교환한다.

#### 장점

1. 자료의 이동 횟수가 n-1번을 넘지 않는다.(시간복잡도가 입력에 따라 변하지 않는다)

#### 단점 

1. 하나의 수를 이동시킬 때마다 매번 정렬되지 않은 부분을 검사해야한다.



### 삽입 정렬

```java
static class InsertionSort implements Sorting {     	//삽입 정렬
        public void sort(int[] a, int num) {			//배열 a와 배열의 길이를 입력받음
            for (int i = 1; i < num; i++) {
                int currentelement = a[i];				//정렬 안된 부분의 가장 왼쪽원소
                int j = i - 1;			//정렬된 부분의 가장 오른쪽 원소로부터 왼쪽 방향으로 삽입할 곳을 탐색
                while (j >= 0 && a[j] > currentelement) {
                    a[j + 1] = a[j];					//맞는 위치를 찾을 때 까지 자리 이동
                    j = j - 1;
                }
                a[j + 1] = currentelement;
            }

        }
    }
```

#### 개념

- 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어 정렬되지 않은 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬하는 알고리즘

#### 장점

1. 이미 배열이 정렬되어 있는 경우라면 n-1번의 비교만 하면 정렬을 마칠 수 있다.(시간복잡도 O(n))
2. 거의 정렬이 되어있는 배열이라면 다른 정렬 알고리즘보다 빠르다.

#### 단점

1. 하나의 수를 이동시키는데 많은 교환이 필요하다.
2. 배열이 클 경우에 적합하지 않다.
3. 데이터의 상태에 따라서 성능의 편차가 크다.



### 쉘 정렬

```java
    static class ShellSort implements Sorting {         //쉘 정렬
        public void sort(int[] a, int num) {

            int n = 0;
            int[] gapCiura = {1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, 8858, 19930, 44842, 100894, 227011,510774, 1149241, 2585792, 5818032, 13090572, 29453787, 66271020, 149109795, 335497038, 754868335, 1698453753};     
            //ciura 갭은 1750까지만 나와 있지만 위키피디아를 참조해서 이 후 갭은 2.25씩 곱해서 정수형의 최대치인 21억 밑에 있는 1698453753까지만 고려했다.
            for (int i = 0; i < 26; i++) {
                if (num < gapCiura[i]) {        //배열의 크기보다 gap이 작도록 설정해주었다.
                    n = i - 1;
                    break;
                }
            }
            int[] gap = new int[n];
            for (int i = 0; i < n; i++) {
                gap[i] = gapCiura[i];           //배열의 크기보다 작은 gap들만 모아놓은 배열을 만들었다.
            }


            for (int x = 0; x < gap.length; x++) {
                int h = gap[gap.length - 1 - x];    //gap이 큰 순서대로 실행해주었다.
                for (int i = h; i < num; i++) {
                    int currentelement = a[i];
                    int j = i;
                    while (j >= h && a[j - h] > currentelement) {
                        a[j] = a[j - h];
                        j = j - h;
                    }
                    a[j] = currentelement;
                }
            }
        }
    }
```

#### 개념

- 삽입정렬을 보완한 알고리즘이다.
- 삽입정렬을 할 때 한 수가 삽입되어야 할 위치에서 멀리 떨어진 곳에 있으면 한칸씩 움직여야 해서 느리다. 
- 배열을 부분적인 배열로 나누어서 빠르게 위치를 이동시킨다.

#### 장점

1. 다른 정렬 알고리즘보다 빠르게 정렬을 할 수 있다.
2. 쉘 정렬의 특징인 간격에 따른 그룹 별 정렬 방식이 하드웨어로 정렬 알고리즘을 구현하는데 매우 적합하다.

#### 단점

1. 배열을 나누는 간격을 잘못 설정한다면 성능이 나쁘게 나올 수 있다.

## 성능분석

- 정렬 알고리즘의 성능을 분석하기 위해 랜덤, 부분적으로 정렬, 역순으로 정렬된 배열을 가지고 각 알고리즘에 넣어서 성능을 분석해 보았다.

결과에 따른 그래프는 이렇게 나왔다.

![실행 시간 그래프]()

쉘 정렬은 속도가 빨라 배열의 크기가 작으면 실행시간의 경향이 잘 보이지 않아 배열의 개수를 20만개~600만개로 해서 실행시켜 보았다.

![쉘 정렬 시간 그래프]()



### 결과 분석

- 거의 모든 경우에서 랜덤한 수로 채워진 배열보다는 부분적으로 정렬된 배열을 정렬하는 것이 실행시간이 더 짧았다.
- 버블 정렬 보다는 선택 정렬, 삽입 정렬이 더 빨랐고, 쉘 정렬이 거의 비교가 되지 않을 만큼 빨랐다.
- 랜덤하게 배열을 채워서 정렬하는데 20000개 쯤 되는곳에서 그래프가 살짝 위로 튀는 것을 발견했다. 왜 그런지는 잘 모르겠다.
- 결과가 생각처럼 나오지 않아서 2시간 정도 인터넷을 찾아보았지만 이렇다 할 결론을 내지 못했다. 내가 이상하게 생각하는 부분은 버블 정렬과 쉘 정렬이 역방향으로 배열이 정렬되었을 때 더 빠르다는 것이다.  혹시 실험을 잘못 했나 하고 순방향으로 배열을 정렬해서 넣어봤으나 순방향이 역방향보다는 훨씬 빨랐다.



#### 버블 정렬의 시간 복잡도

- 최선의 경우 	: 비교하는데 O(n) 시간, 교환하는데 O(1) 시간
- 최악의 경우     : 비교하는데 O(n^2)시간, 교환하는데 O(n^2)시간
- 평균적인 경우 : 비교하는데 O(n^2)시간, 교환하는데 O(n^2)시간

#### 선택 정렬의 시간 복잡도

- 최선의 경우 	: 비교하는데 O(n^2)시간, 교환하는데 O(n)시간
- 최악의 경우     : 비교하는데 O(n^2)시간, 교환하는데 O(n)시간
- 평균적인 경우 : 비교하는데 O(n^2)시간, 교환하는데 O(n)시간

#### 삽입 정렬의 시간 복잡도

- 최선의 경우 	: 비교하는데 O(n)시간, 교환하는데 O(1)시간
- 최악의 경우     : 비교 및 교환 하는데 O(n^2)시간
- 평균적인 경우 : 비교 및 교환 하는데 O(n^2)시간

#### 쉘 정렬의 시간 복잡도

- 쉘 정렬의 시간복잡도는 아직 풀리지 않은 문제이다.



































